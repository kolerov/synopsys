Building and running binaries
=============================

Build binaries for bare metal targets using GCC
-----------------------------------------------

Consider a simple example code (save it as ``main.c``):

.. code-block:: c

    #include <stdio.h>

    int main()
    {
        printf("Hello\n");
        return 0;
    }

QEMU has ``arc-sim`` board for testing purpose. If ``-semihosting`` option is not passed to QEMU
then it creates a character device on hard coded ``0x90000000`` address. A program built with
``-specs=qemu.specs`` uses this address for all write operations.

Build and run the program for ARC HS4x:

.. code-block:: text

    $ arc-elf32-gcc -mcpu=archs -specs=qemu.specs main.c -o main.elf
    $ qemu-system-arc -M arc-sim -cpu archs -m 1G -monitor none -display none -nographic -no-reboot -serial stdio -kernel main.elf

Build and run the program for ARC HS5x:

.. code-block:: text

    $ arc64-elf-gcc -mcpu=hs5x -specs=qemu.specs main.c -o main.elf
    $ qemu-system-arc -M arc-sim -cpu hs5x -m 1G -monitor none -display none -nographic -no-reboot -serial stdio -kernel main.elf

Build and run the program for ARC HS6x:

.. code-block:: text

    $ arc64-elf-gcc -mcpu=hs6x -specs=qemu.specs main.c -o main.elf
    $ qemu-system-arc64 -M arc-sim -cpu hs6x -m 1G -monitor none -display none -nographic -no-reboot -serial stdio -kernel main.elf

If ``-semihosting`` option is passed to QEMU the it uses the same input/output interface as
nSIM with an option ``-on nsim_emt``:

.. code-block:: text

    $ arc-elf32-gcc -mcpu=archs -specs=nsim.specs main.c -o main.elf
    $ qemu-system-arc -M arc-sim -cpu archs -m 1G -semihosting -monitor none -display none -nographic -no-reboot -serial stdio -kernel main.elf

Build binaries for bare metal targets using MetaWare Development Toolkit
------------------------------------------------------------------------

MetaWare's standard runtime library does not support input/ouput interfaces of QEMU for ARC
(both ``-semihosting`` mode and a simple mode using ``0x90000000`` address). But it's possible
to implement your own hostlink library for MetaWare to meet QEMU's requirements. Actually
you have to implement just one function to add support of simple output:

.. code-block:: c

    int _write (int handle, const char *buf, unsigned int count)
    {
        unsigned int i = 0;
        while (i < count)
        {
            *(char *) 0x90000000 = buf[i++];
        }
        return count;
    }

It's a slightly modified ``_write`` from ``libqemu.a`` for
`Newlib <https://github.com/foss-for-synopsys-dwc-arc-processors/newlib/blob/arc-2022.09/libgloss/arc/qemu-write.c>`_.
Save it as ``write.c`` file. Compile it along with ``main.c``: 

.. code-block:: text

    $ ccac -av2hs -Hhostlib= main.c write.c -o main-ccac-archs.elf
    $ ccac -av3hs -Hhostlib= main.c write.c -o main-ccac-arc32.elf
    $ ccac -arc64 -Hhostlib= main.c write.c -o main-ccac-arc64.elf

Run them using QEMU::

    $ qemu-system-arc -M arc-sim -cpu archs -m 1G -monitor none -display none -nographic -no-reboot -serial stdio -kernel main-ccac-archs.elf
    $ qemu-system-arc -M arc-sim -cpu hs5x -m 1G -monitor none -display none -nographic -no-reboot -serial stdio -kernel main-ccac-arc32.elf
    $ qemu-system-arc64 -M arc-sim -cpu hs6x -m 1G -monitor none -display none -nographic -no-reboot -serial stdio -kernel main-ccac-arc64.elf

.. warning::
    QEMU for ARCv3 does not support code generated by ``ccac`` right now. It happens because ``ccac`` generates
    instructions which are absent in QEMU (see `this issue <https://github.com/foss-for-synopsys-dwc-arc-processors/toolchain/issues/513>`_).

Run a GDB server
-----------------

Read QEMU's `documentation <https://qemu-project.gitlab.io/qemu/system/gdb.html>`_ for details.

Run a GDB server with default port 1234::

    qemu-system-arc -M arc-sim -cpu archs -m 1G -s -S -monitor none -display none -nographic -no-reboot -serial stdio -kernel main.elf

Make QEMU listeting through UNIX socket::

    qemu-system-arc -M arc-sim -cpu archs -m 1G -chardev socket,path=/tmp/gdb-socket,server=on,wait=off,id=gdb0 -gdb chardev:gdb0 -S -monitor none -display none -nographic -no-reboot -serial stdio -kernel main.elf


Running the Linux kernel
------------------------

You have to use ``virt`` machine for running Linux kernels:

.. code-block:: text

    qemu-system-arc -M virt -cpu archs -m 1G  -display none -nographic -monitor none -kernel vmlinux

Buildroot also generates an image named ``loader`` for ARC HS6x. It must be used instead of ``vmlinux``:

.. code-block:: text

    qemu-system-arc64 -M virt -cpu hx6x -m 1G  -display none -nographic -monitor none -kernel loader
